Microservice is an evolving pattern that has managed to gain a lot of attention lately. An architecture that follows this pattern has several separate deployable units. Microservice architecture has many Service components of varying magnitudes but a well-defined purpose (lot of times single purposed) and fine-grained. Deciding the right granularity remains the biggest challenges with the pattern. Apart from its ability to be developed sequentially, these separate service units are testable and deployable independently & parallely. The pattern itself is distributed in nature. Each component is decoupled from the other and talk to each other using some standard access protocols such as SOAP, REST, JMS/AMPQ, RMI etc. Microservices share a lot of commonalities with SOA, this is because this was a pattern that arouse out of the difficulties and lessons that SOA taught. SOA is very abstract and offers service Orchestration, but complex to implement. Microservices eliminate the need for orchestration, simplifying connectivity and access to service components e.g. an Application where AngularJS serves as a front end interact with a lot micro services via an Application Programme Interface due to its natural support for RESTful calls. 
Each module can be scaled independent of the other unlike the monolithic deployments where the whole unit would have to replicated as another cluster node instance. Unlike in the N Tier model instead of dividing team in accordance to the layers, e.g. UI team deals with the Presentation Tier JEE Team deals with the Business, Persistence Tiers and DBA with the Database layer, Microservices architecture demands small units within the team that are membered by people from all trades based on logical business separations. 
Thus 3 of the popular ways of implementing the pattern: API Based, Application Based and Centralized Messaging Based.
The API Based model has fine-grained services that can contain specific business functions.  
Application REST based topology more tightly coupled and servers traditional web-based applications or fat clients. The topology is ideal for small to medium complexity business use cases.
The centralized message broker topology is similar to REST based topology but instead of REST for remote calls it uses a centralized Message Broker.
If one finds a need to orchestrate or perform interservice communication, then he has to reconsider the microservices components, for it could be too fine grained. The interservice communication could be made possible with a shared database. One would easily end up violating the DRY principle with this implementation but sometimes repeating small utilities are inevitable and agreeable. Spanning the transactions across services is a real challenge with this pattern. Such requirements would require some sort of transaction compensation framework for rolling back the transactions, which could add signification complexity to the application.
The pattern has an overhead in terms of communication since it has to make remote calls to the Service layer. This could have an effect on the overall performance of the application.
Otherwise this pattern is easy to develop due to its fine grained functionality nature. If designed appropriately the pattern could lend itself to hot deployment rather than the 'Weekend Big Bang' deployment. The services can scale itself independently. It possess high testability.