In this article we talk about transactions from many aspects. We discuss:
ACID, the transaction isolation levels.
Various transaction models
Pessimistic & Optimistic locking
XA Trasnactions
Common Transactional Design Pattens
How to achieve XA like behavour in a non XA environment.
How Databases such as MongoDB achieve consistency of data
CAP Theorm

ACID, the transaction isolation levels
ACID as we all know stands for
Atomicity: Changes are either Committed or Rolled back. We don’t have a superposition of states.
Consistency: Every system has business rules. Before and after the changes the system should be consistent with these Business Rules. Though not necessirily the case during a transaction.
Isolation: In a ball dance, you probably don’t want to be stepped on your shoe by someone else. Like wise you don’t want anyone to fiddle with your data when you are updating a row in a RDBMS. Isolation is at your rescue. There are primarily 4 Isolation Levels for achieving concurrency.
Read Uncommited: This is the lowest level of Isolation. Also called Dirty Read, one can read uncommited data. Generally not recommended in multithreaded environment.
Read Committed: One way to solve the Dirty Read problem is to switch to the next level of Isolation or Read Committed. With this Isolation level, only committed data from other transactions will be visible. Here again you might be surprised with a collegues commited data during your transaction.
Repeatable Read: If Read Committed Isolation level is not good enough then the next higher level of isolation is the Repeatable Read. Multiple reads are guaranteed to return the same result during every reads until the transaction is active whether or not the other transacations are committed or not.
Serializable: Though Read Committed or Repeatable Read is practically good enough for most applications, it does come with a trade off of what is know as ‘Phantom Reads’. Within the course of a transaction, two selects would return different number of records. To avoid this one may have to set isolation to Serializable a.k.a Table Level Lock. This level guarantees the table itself will not be touched during an active transaction. This is the higest level of Isolation. Summary: There is however a relation between Consistency, Isolation and Concurrency. Though higher levels of Isolation guarantees better Consistency it does come with a trade off of Lower Concurrency in other words Lower Performance. It is generally recommended to use one of these Isolation Level as much as possible, infact few databases does only support these two levels of Isolation. While you could indicate from your code the level of isolation, do note that your underlying datastore must support that level inorder to work as expected.
Durability: Changes are persistent or permenant once committed.

[Various transaction models] There are 3 types of Transaction Models.

Local Transaction Model: As the name suggests we rather deal with the Actual Resource via Local Resource Manager. In case of a Database we control the transaction by setting the autocommit flag to false and preforming a commit or rollback of the transaction to achieve the desired effect. This way we can control multiple database calls from within one transaction. This however comes with a few cons. While there is a need for a lot of boiler plate code, Local transaction model is not very good at coordinating between multiple resource using XA (Extended Architecture) global transaction. Local transactions require more coding and is prone to errors unlike in Declarative Transaction where most of the code are managed in the form of Aspects.
Programmatic Transaction Model:
Declarative Transaction Model

To Be Completed.
