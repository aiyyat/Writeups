Proxying in Software is often associated with the word "Automagically working". One such an arena where proxying conceals the complexity and secretly decorates the business logic is Spring Transactions. Be it the Container Managed Transactions in EJB using JTA or Spring Transactions, all use proxying to attain their goals.
Below is a very simple example to demonstrate its working. The example below is that of a bank account which also has an ATM where the user can withdraw his money. There are primarily 3 service beans in the case. 
An ATMServiceBean that deals with the user interactions.
A MoneyDispatcherBean that dispatches money by printing the dispatched money onto the screen of course. ;)   
An AccountBean that contains  all the interactions with the Bank account such as create account and with draw money.
In order to demonstrate Spring transactions, We have introduced a use case with some of the following Rules:
1) Bank does not support overdraft.
2) The money dispatcher is a system that cannot dispatch more than $4000 in one go.
Hence the ATM has a built in feature to withdraw Twice, ie a person can withdraw money upto $8000 in one transaction, provided he has enough balance. Now the catch here is, let us say he has a balance of $2000 and he requests ATM to "withdrawTwice" $1001, the MoneyDispatcer prepares itself to withdraw $1001 but the subsequence withdrawal will fail since the bank doesn't have an overdraft facility resulting in the whole transaction to roll back.
Spring Transactions primarily have 3 players that may it work. First is the proxy Entity Manager. Spring as such doesn't provide any EntityManager implementation instead context aware proxies of the actual Entity Manager. This is usually a ThreadLocal variable that can retrived based on the current thread of execution. A piece of code acts on this proxy as if it were acting on the real EntityManager implementation. There there is a Transaction Aspect that acts around the target method call. When the method is called from the ApplicationContext container the proxy creates a seperate transaction if required or joins with the existing transaction as per the need of the day. Then there is a Transaction Manager which makes the decision of if a new Transaction is required or not. 
JPA Entity:
[code language="java"]
@Entity
@Table(name="BANK_ACCNT")
public class BankAccount implements Serializable {
	private static final long serialVersionUID = 8209188784883901858L;
	@Id
	@Column(name = "ACC_NUM")
	String accountNumber;
	@Column(name = "ACC_HOLDER")
	String accountHolderName;
	@Column(name = "BALANCE")
	double balance;
...
[/code]
AccountBean
[code language="java"]
@Service
public class AccountBean {
	@PersistenceContext
	EntityManager em;

	/**
	 * REQUIRES_NEW is a Transaction Attribute where a new transaction context
	 * is created every time the method is invoked.
	 * 
	 * @param account
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public void createBankAccount(BankAccount account) {
		em.persist(account);
	}

	/**
	 * Here supports means that the existing transaction is propogated if one is
	 * already present, and ignored if there ain't one
	 * 
	 * @param accountNumber
	 * @return
	 */
	@Transactional(propagation = Propagation.SUPPORTS)
	public BankAccount fetchBankAccount(String accountNumber) {
		return em.find(BankAccount.class, accountNumber);
	}

	/**
	 * Here the Transaction is mandatory. If it doesn't find one it throws an
	 * IllegalTransactionStateException.
	 * 
	 * @param accountNumber
	 * @param money
	 */
	@Transactional(propagation = Propagation.MANDATORY)
	public void withdraw(String accountNumber, double money) {
		fetchBankAccount(accountNumber).withDraw(money);
	}
}
[/code]
[code language="java"]
@Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public class ATMServiceBean {
	@Autowired
	AccountBean account = null;

	@Autowired
	MoneyDispatcherBean dispatcher = null;

	/**
	 * Actual A/C Transaction happens in this method.
	 * 
	 * @param accountNumber
	 * @param money
	 * @param times
	 */
	private void withdrawTimes(String accountNumber, double money, int times) {
		double totalAmount = 0.00d;
		for (int i = 0; i < times; i++) {
			account.fetchBankAccount(accountNumber).withDraw(money);
			totalAmount += dispatcher.prepareToDispatch(money);
		}
		System.out.println("Dispatching $" + totalAmount);
	}

	/**
	 * The Method that was initially there, all the while.
	 * 
	 * @param accountNumber
	 * @param money
	 */
	public void withdraw(String accountNumber, double money) {
		withdrawTimes(accountNumber, money, 1);
	}

	/**
	 * A work around the bank provided to over come the MoneyDispatchers
	 * limitation of providing upto only $4000
	 * 
	 * @param accountNumber
	 * @param money
	 */
	public void withdrawTwice(String accountNumber, double money) {
		withdrawTimes(accountNumber, money, 2);
	}
}
[/code]
[code language="java"]
@Service
public class MoneyDispatcherBean {
	@Transactional(propagation = Propagation.MANDATORY)
	public double prepareToDispatch(double amount) {
		if (amount > 4000) {
			throw new IllegalStateException("Cannot dispatch more than $4000");
		}
		System.out.println("ATM preparing to dispatched $" + amount);
		return amount;
	}
}
[/code]
Application Context configuration File: 
[code language="xml"]
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:p="http://www.springframework.org/schema/p" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
		p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost/bankdb"
		p:username="root" p:password="admin" p:initialSize="5" p:maxActive="10">
	</bean>

	<bean
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"
		id="entityManagerFactory">
		<property name="dataSource" ref="dataSource" />
	</bean>

	<context:component-scan
		base-package="com.technicalyorker.springtransaction.services" />

	<bean class="org.springframework.orm.jpa.JpaTransactionManager"
		id="transactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>

	<tx:annotation-driven transaction-manager="transactionManager" />
</beans>
[/code]
Test Case:
[code language="java"]
public class AppTest extends TestCase {
	public void testApp() {
		ApplicationContext context = new ClassPathXmlApplicationContext(
				"config.xml");
		System.out.println(Arrays.toString(context.getBeanDefinitionNames()));
		ATMServiceBean atmServiceBean = (ATMServiceBean) context
				.getBean("ATMServiceBean");
		AccountBean accountBean = (AccountBean) context.getBean("accountBean");
		String accountNumber = "SA-34563";
		BankAccount account = new BankAccount();
		account.setAccountNumber(accountNumber);
		account.setAccountHolderName("Boon Lay");
		account.setBalance(3000.00);
		accountBean.createBankAccount(account);
		System.out.println(accountBean.fetchBankAccount(accountNumber));
		atmServiceBean.withdraw(accountNumber, 1000);
		atmServiceBean.withdrawTwice(accountNumber, 1001);
	}
}
[/code]
